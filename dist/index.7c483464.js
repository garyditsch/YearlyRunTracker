const getRunData=async(t,e)=>{try{return(await fetch(t)).json()}catch(t){console.log("get data error",t)}finally{console.log("get data has finished")}},runDateValues=async t=>t.map((t=>({date:d3.timeDay(new Date(t["Activity Date"])),value:.6213712*Number(t.Distance),minutesOfDayStart:(60*new Date(t["Activity Date"]).getHours()+new Date(t["Activity Date"]).getMinutes()-new Date(t["Activity Date"]).getTimezoneOffset())/60,speed:60/(2.2369*t["Average Speed"]),runDuration:t["Elapsed Time"]/60,isFortyFive:45<=t["Elapsed Time"]/60,dv:t}))),theData=async t=>{try{Date.now();const e=await getRunData(t);Date.now();return await runDateValues(e)}catch(t){console.log("the data function error",t)}finally{console.log("done with the data function")}},groupedMonthlyData=async(t,e,a=!0)=>{try{Date.now();const n=await getRunData(t),o=await getRunData(e);Date.now();const s=[...n,...o],c=await runDateValues(s);console.log(c);const i=c.sort(((t,e)=>t.date-e.date)),r=d3.nest().key((t=>t.date.toLocaleString("default",{month:"long",year:"numeric"}))).entries(i).map((t=>{const e=t.values.reduce(((t,e)=>t+e.value),0);return{key:t.key,distance:parseInt(e),runCount:t.values.length}}));if(!0===a){const t=r.sort(((t,e)=>e.distance-t.distance));return console.log(t),t}return console.log(r),r}catch(t){console.log("the data function error",t)}finally{console.log("done with the data function")}};
//# sourceMappingURL=index.7c483464.js.map
